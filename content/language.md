# НАЧАЛЬНЫЕ СВЕДЕНИЯ О ЯЗЫКЕ ПРОГРАММИРОВАНИЯ JULIA

Если вы знакомы с языком Python, то очень многое в языке Julia вам покажется знакомым. Но есть и существенные различия. 

Напирмер, в языке Julia отступы не имеют принципиального значения, такое как они имеют в языке Python, где отступы определяют структуру кода. И не надо ставить двоеточия в конце заголовков функций, циклов и т.д., как в Python. Вместо всего этого используется ключевое слово `end`, ограничивающее тело той или иной конструкции языка (см. ниже).

## Функции

Например, определение функции может выглядеть так
```julia
function f(x)
    return x^2
end
```
или так
```julia
function f(x)
    x^2 # функция всегда возвращает значение последнего оператора в своем теле
end
```
или даже так
```julia
f(x)=x^2
```
Последний способ обычно используют для совсем коротких определений.

Однако в отличие от языка Python, где типы аргументов функций и возвращаемого функцией результата не аннотируются, в языке Julia их типы могут быть аннотированы, но делать это не обязательно. 

Например, можно было бы дать еще следующие 2 определения
```julia
function f(x::Int)
    return x^3
end

function f(x::Float64)
    return x^4
end
```
В результате получим еще 2 метода (варианта) функции f, а всего, если учесть передыдущее определение, - будет уже 3 метода. В первом определении, где тип аргумента явно не аннотировался, он (тип), на самом деле, имел значение Any - тип, стоящий во главе иерархии всех типов Julia. И все эти 3 определения одновременно быдут существовать, какое из них будет использовано - зависит от фактического типа аргумента функции (т.е. с аргументом какого типа будет вызов функции). Это называется [множественной диспетчеризацией](https://techytok.com/lesson-multiple-dispatch/). 

Зачем нужна множественная диспетчеризация, и как ей правильно пользоваться в языке Julia - это предмет отдельного разговора. Но заранее заметим, что эта тема имеет в Julia первостепеное значение. 

## Циклы
### "Арифметический" цикл
```julia   
for a in collection 
    println(a)
end

где collecnion - это может быть диапазон, массив (Array), генератор, строка (String), множество (Set), словать (Dict) - см. ниже. 

Например collection = [10,20,30,40,50] - это массив (в данном случае - вектор-столбец)

for i in eachindex(collection) # перебираются индексы элементов колллеции
    println(i)
end

for (i,a) in enumerate(collection) # перебираются пары индекс-значение элементов колллеции
    println(i," -> ", a) 
end
```

### Цикл с предусловием
```Julia

while условие_продолжения_цикла
    ...
end
```
## Значение, возвращаемое оператором цикла

В языке Julia любой оператор цикла имеет значение nothing (Nonthing), что обозначает "отсутствие" значения. Это значит, что это значение можно присвоить какой-либо переменной или вернуть из функции (речь, конечно, идет о некоторой формальности).

## Операторы изменения поряка выполнения цикла

Иногда бывает необходимо прервать выполнение цикла при выполнении некоторого дополнительного условия - для этого существует оператор `break`. 

Имеется также оператор `continue`, который в отличии от break не прерывеат выполнение цикла, а только переключает процесс на следующую итерацию, не дожидаясь выполнения  всех озаписанныз после него действий в теле цикла.

## Вложенные циклы

Любой цикл может содержать в своем теле другой цикл. Такие циклы называются вложенными.

При необходимости "выпрыгнуть" за пределы внешнего цикла из какого-либо внутреннего (обычно - при выполнении некоторго условия) следует воспользоваться макросоми @goto и @label. Например,
```julia
for ...
    ...
    for ... 
        ...
        if ...
            @goto label_name
        end
        ...
    end
    ...
end
@label label_name
```
С помощью оператора break возможено "выпрыгивание" только за пределы одного текущего цикла. И если пользоваться этим оператором применительно к "выпрыгиванию" за пределы нескольких вложенных циклов, то понадобится целая цепочка таких "выпрыгиваний", а с помощью @goto - @label это можно будет сделать за одно действие.

## Ветвления

Ветвления выглядят в общем случае так
```julia
if условие
    тело
end

if условие
    тело_if
else
    тело_else
end

if условие_1
    тело_1
elseif условие_2
    тело_2
...
elseif условие_N # число провряемых усорвий может быть любым
    тело_N
else # эта секция может и отсутствовать
    тело_else
end
```
## Значение, возвращаемое оператором ветвления

В языке Julia начением оператора ветвления является значение последнего оператора в теле выполняемого блока.
Например, если
```julia
a=if 2>0
    10
else
    -10
end
```
то в результате переменная a получит значение 10.

## Переменные, типы, операции, выражения, присваивания

Также как и Python язык Julia является языком с динамической типизацией и с выводом типов. Первое означает, что переменная с заданным именем может изменить свой тип в процессе выполнения программы. А второе означает, что типы значений, которыми инициализируются переменные не обязательно явно указывать, компилятор Julia сумеет правильно определить (вывести) тип значения исходя из контекста (например, из способа записи числового значения). 

Например
```julia
x=1   # - тип переменной будет Int64 (или просто - Int)
x=1.0 # - тип переменной (с прежним именем) будет Float64
x=1//2 # - тип переменной будет Ranional{Int64}
```
С числовыми значениями можно выполнять обычные арифметические опрерации и применять к ним стандартные математические функции. Пример математического выражения
```julia
1+2*(sin(x)-cos(y))/exp(x+y^3)
```
Имеются логические значения `true`, `false` (тип `Bool`), к ним применимы стандартные логические операции `&&` ("и"), `||` ("или"), `!` ("не")
(надо с осторожностью относится к побировым опереациям `&`, `|`, `~`, и неиспользовать их вместо соответствующих логических операций - это может приводить к досадным недороазумениям)

Операции сравнения: `==` ("равно"), `===` ("тождественно равно"), `!=`, `!==`, `<`, `>`, `<=`, `>=`.
Возможны также двойные сравнения `1<2<3` - даст значение `true`. 

## Итерируемые объекты 
Итерируемые объекты, это такие объекты, которые могут использоваться в цикле for:
```julia
    for элемент in некоторый_итерируемый_объект
        ...
    end
```
Итерируемыми объектами, в частности, являются массивы, диапазоны, генераторы, кортежи, строки, множества, словари.

### Массивы

Индексация в массивах в языке Julia начинается с 1, так как это принято в математике (в отличие от языка Python, где индексация начинается с 0). Индексы записываются в квадратных скобках. Массивы в Julia являются динамическими, т.е. в процессе выполнения программы в них можно добавлять новые элементы, или удалять из них элементы (но к этой возможности надо относиться с осторожностью, т.к. это может явится причиной существенного замедления выполнения программы).   

Например,
```julia
a=[10,20,30,40] # - это 1-мерный массив (вектор-столбец)
a[1] - это 10
a[end] - это 40
length(a) - длина массива, равна 4
push!(a,50) - добавляет в конец массива еще один элемент (50)
pop(a) - извлекает из конца массива элемент
a[2]=100 - присваивает новое значение 2-му элементу массива
```    
Переменная `a` - это ссылка, т.е. если
```julia
b=a 
```
то `b` - это будет ссылка на тот же самый массив, так что
изменение значения элемента в `b` будет означать и изменение в `a`. Например
```julia
b[2]=0
```
даст, что `a[2]` - это `0`.

Чтбы получить копию массива, надо использовать функцию copy. Например,
```julia
с=copy(a)

c[1]=1000
```
но `a[1]` - по-прежнему будет иметь значение 10.

В Julia существует понятие "среза" массива. Срезы представляют соответствующие части существующего массива. Например, если имееттся массив a длиной 10, то его "срез", содержащий первую половину, можно получить так:
```julia
b=a[1:5]
```
Важно, однако, отметить, что "срезы" в Julia (в отличие, например, от Python) **копируются**. Чтобы получить **ссылку** на "срез" следовало бы сделать так
```julia
b=@view a[1:5]
```
Вообще работа с массивами в языке Julia реализована очень удобно и эффективно. В этом отношении (и не только в этом) Julia существенно превосходит язык Python.

В Julia массивы могут быть самых разных типов. Они также могут быть одномерными, двумерными, многомерными, разряженными, динамическими, статическими. В принципе, и индексация возможна не только с 1, но и с любого другого произвольно заданного значения, включая 0 (но для этого пришлось бы импортировать специальный модуль).

### Диапазоны

Кроме массивов в языке Julia, как и в Python, есть еще диапазоны, которые более экономично, по сравнению с массивами, представляются в памяти. Но в Julia диапазоны записвываются иначе. 

Например, `1:10`, или `1:2:10` (2 - это шаг, он записывается в середине конструкции; по умолчанию шаг равен 1). 

Дапазоны в Julia, в отличие о от Python, являются замкнутыми, т.е., например, число 10 в ходит в `1:10`, и число 11 входит в `1:2:11` (но вот число 10 в `1:2:10`, разумеется, - не входит). 

Кроме того, начальное, конечное значения диапазона и щаг не обязательно целые числа, они могут быть и с плавающей точкой.

### "Списковые включения"

Массивы могут создаваться разными способами. Например, можно использовать так называемое списковое включение:
```julia    
[i^2 for i in 1:10]
```
В данном случае получится массив квадратов первых `10` натуральных чисел. Эта конструкция вполне аналогична тому, что есть Python.

### Генераторы 

А вот такая конструкция
```julia    
(i^2 for i in 1:10)
```
подобна предыдущей, но результатом ее выполнения является так называемый генератор (последовательности), а не массив. 

Отличие в том, что все члены последовательности сразу не размещаются в памяти, а генерируются по мере надобности по очереди. 

Например, такая конструкция могла бы съэкономить расход памяти в следующем цикле
```julia
for k in (i^2 for i in 1:1_000_000) ... end
```
### Кортежи

Генераторы не нужно путать с кортежами (Tuple), которые внешне выглядят похоже:
```julia
(1,2,3,4) # - это кортеж
```
Это кортеж - в отличие от массивов кортежи не изменяемы, т.е. изменить значение отдельного элемента кортежа нельзя. 

Например,
```julia
a=(10,20,30,40) # - это кортеж
a[1]     # - равно 10
a[1]=100 # - ошибка: кортеж изменить нельзя
```
Кортежи могут использоваться в операторе присваивания, например:
```julia
a,b,c = 1,2,3 # это тоже самое, что и (a,b,c) = (1,2,3)
```
в результате получится, что `a=1, b=2, c=3`.

Картеж из одного элемента записвывается с помощью запятой в конце, например `(2,)` - это кортеж, а `(2)` - это просто `2`.

Кортежи могут содержать элементы разных типов. Существуют также **именованные** кортежи (`NanedTuple).

### Строки

Строки (`String`) - тоже неизменяемые объекты:
```julia
s="abcdefgh"
s[1] # - это есть символ ASCII 'a' (не строка)
s[1]='b' # - ошибка: изменить строку не возможно
```
Со строками возможны операции:
```julia
"absd"*"efgh" # - операция конкатенации (в Python аналогичная операция записывается с помощью символа "+")

"abc"^3 # - операция дублирования, в данном случае - 3х кратного (в Python аналогичная операция записывается с помощью - "*")
   
n=3 
println("number = $(n)") # - вставляет в строку на место переменной n ее значение (это называется "интерпляцией строк") 

number = 3
```   

### Cтандартные контейнеры

В языке Julia, как и в языке Python, помимо массивов существуют также множества (`Set`) и словари (`Dict`).
  
## Интроспекция

Для выяснения того, какого типа то или иное значение, имеется встроенная функция typeof.
Также в REPL имеется удобная встроенная система помощи, с помощью которой можно получить много полезной информации о типах данных и функциях языка Julia.

## Система встроенных и пользовательские типов

Помимо многочисленных встроенных типов, среди которых есть как абстрактные, так и конкретные типы, и которые образуют некоторую древовидную иерархическую структуру, в языке Julia возможно создание (встраивание в указанное иерархическое дерево) пользовательских типов данных. Во главе иерархии типов стоит абстрактный тип Any. На концах древовидной структуры, и только на них, находятся все конкретные типы.

Пользовательские типы данных также могут быть как абстрыктными, так и конкретными. Абстрактные типы не содержат данных, они предназначены только для того, чтобы быть родительскими типами для для каких-либо других типов, абстрактных или конкретных.

Абстрактные типы определяются с помощью специальной синтаксической конструкции abstract type-end, и не содержат ничего, кроме указания имени нового типа и имени его родительского типа.

Конкретные же типы определяются с помощью конструкции struct-end, подобно тому, как это имеет место в C-подобных языках. Но, конечно, имеются и существенные отличия от этих языков. 

Различные типы могут находиться между собой в отношении предок-потомок. Для выяснения того, какие типы являются дочерними, а какой - родительским, для какого-либо заданного типа имеются специальные встроенные функции `subtypes`, `supertype`, соответственно. 

## Перезагрузка REPL Julia

При работе в REPL иногда возникает необходимость отменить ранее сделанные определения. Напимер, если была создана переменная `x`:
```julia
julia> x=10000
```
то удалить её саму из области памяти REPL окажется невозможным. То есть, невозможно именно удалить имя, а не изменить значение. Можно лишь присвоить этой переменной значение `nothing` (тип этого значения — `Nothing`), что будет означать «отсутствие» значения.
```julia
julia> x=nothing
```
(значение-то на самом деле есть, просто оно — `nothing`, поэтому и поставлены кавычки).

Если была определена функция, например,
```julia
julia> f(x::Int)=x^2
```
то удалить её из области REPL тоже не получится. Но её можно будет переопределить, сохранив типы аргументов, например:
```julia
julia> f(x::Int)=x^3
```
Но вот если изменить при этом тип аргумента, например:
```julia
julia> f(x::Float64)=x^2
```
то окажется, что старое определение не исчезнет, а будет одновременно существовать два метода одной обобщённой (`generic`) функции (см. выше о множественной диспетчеризации).

В любом случае, чтобы совсем избавиться от сделанных ранее определений, необходима перезагрузка REPL. Она выполняется с помощью встроенной функции `exit`:
```julia    
julia> exit()
```
В среде VS Code можно, однако, открыть ещё и новый экземпляр REPL, и продолжить работу в нём, сохранив прежний экземпляр REPL (между этими экземплярами можно будет спокойно переключаться, но они будут полностью изолироваными, никакой связи между ними не будет).

## Немного о терминологии

В классических объектно-ориентированных языках программирования говорят о *классах*, имеющих *методы*. Так обстоит дело, например, в языке Python. В языке С++, однако, вместо понятия «метод» используется понятие «функция-член класса», а ещё там есть функции, «дружественные» классу.

В таких языках *класс* — это специальная конструкция, позволяющая определять внутреннюю структуру данных, содержащуюся в каждом создаваемом с помощью констркутора класса в памяти комьютера объекте данного класса и те операции или действия, которые будут доступны программисту при программировании действий с объектами этого класса. Указанные операции или действия оформляются в виде методов класса.

А вот в языке Julia вместо классов есть типы. У типов, как и у классов, есть конструкторы, но вместо методов у них есть функции. А методы в языке Julia, в свою очередь, есть только у функций (см. выше). При этом принято говорить, что тот или иной конкретный метод *специализирует* обобщённую (`generic`) функцию.

Обычно также в объектно-ориентированных языках используется точечная нотации для вызова какого-либо метода для данного объекта. Например, команда сделать шаг в направлении `Nord` в языке Python могла бы выглядеть так: `r.move(Nord)`. Но в языке Julia точечная нотация для вызова функций, ассоциированных с данным типом, не используется. Объекты какого-либо типа могут являться лишь обычными аргументами своей функции.

## O Julia и Python

Важно ещё отметить некоторое (поверхностное, на самом деле) сходство языка Julia с языком Python. Благодаря этому сходству, например, часто удаётся выяснить имя и описание какой-либо вдруг понадобившейся стандартной функции Julia (если по каким-то причинам это не удалось сделать напрямую): велика вероятность того, что нужная функция называется и действует так же, как и в Python. При этом на сегодняшнй день информацию по языку Python на русском языке найти значительно проще.

## Более подробные сведения о языке

Более подробные сведения о языке Julia можно почерпнуть, например, 

[здесь](https://techytok.com/from-zero-to-julia/), а также [здесь](http://www.lib.unn.ru/students/src/JULIA_tutorial.pdf), или [здесь](https://biologo.ru/korotko-o-yazike-programmirovaniya/index.pdf).

Однако информация о некоторых функциях, содержащаяся в двух последних источниках, может оказаться устаревшей, т.к. она относится к еще не стабильным версиям языка (до 1.0).

Для более полного ознакомления с языком следует обращаться к [фирменной документации](https://docs.julialang.org/en/v1/)

Дополнительные ссылки на полезные источники информации о языке Julia собраны [здесь](links.md)

----------------

[Назад](../README.md)
